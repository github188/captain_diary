http://blog.csdn.net/ty4315/article/details/52216135  这个系列博客不错


1.   yum  -y install java-openjdk*

2. wget  https://download.elastic.co/elasticsearch/elasticsearch/elasticsearch-1.4.4.tar.gz

3.mv elasticsearch-1.4.4 /usr/local/

4 cd /usr/local
5. tar -zxvf elasticsearch-1.4.4

6.  cd elasticsearch-1.4.4/bin

7. sh elasticsearch-1.4.4 

xshell复制一个会话出来，继续  
Put创建索引
curl -X PUT http://localhost:9200/shb02/student/1 -d '{"name":"jack","age":30,"info":"Ilove you"}'

返回  {"_index":"shb02","_type":"student","_id":"1","_version":5,"created":false} 多执行几次，每次version都会加1  id没有变化，说明
put是幂等操作，也就是如果存在该id的数据，那么就修改这条数据，如果不存在，就创建这条数据。

执行put后有返回值

_index索引名称

_type类型名

_version版本号

created:true表示是新创建的。

上面的命令每执行一次version就会加1，-XPUT必须制定id
POST创建索引
curl -X POST http://localhost:9200/shb01/student -d '{"name":"tom","age":21,"info":"tom"}'

Post创建索引

curl -XPOST http://localhost:9200/shb01/student -d '{"name":"tom","age":21,"info":"tom"}'

{"_index":"shb01","_type":"student","_id":"AVadzuNgxskBS1Rg2tdp","_version":1,"created":true}

使用post创建索引数据，-XPOST可以指定id，此时如果存在相同数据则是修改，不指定id的话会随机生成id，且每次执行都会生成新数据。

 

如果需要每次执行都产生新的数据可以使用post命令且不指定id。

如果使用put命令则需要增加create，命令格式如下

curl -XPUT http://localhost:9200/shb01/student/1/_create -d '{"name":"jackk","age":31}'

curl -XPUT http://localhost:9200/shb01/student/1?op_type=create -d '{"name":"jackk","age":31}'

以上两条命令执行时如果存在id相同的数据则会给出error信息

{"error":"DocumentAlreadyExistsException[[shb01][2][student][1]: document already exists]","status":409}

 

Post与put的区别

Put是等幂操作，即无论执行多少次结果都一样，例如DEL无论删除多少次索引库中的结果都一样，put只要指定了id且数据不变无论执行多少次索引库中的数据都不变，
只有version会变化。

Post每次执行都会产生新数据。 post 相同id的数据会强行覆盖 put则会报错，提示该id数据已存在

查询

1：查询索引库shb01中的类型student

浏览器：http://192.168.79.131:9200/shb01/student/_search?pretty   查询shb01库下面的student表   
http://123.207.56.239:9200/shb01/_search?pretty   查询shb01下面的所有数据
http://123.207.56.239:9200/_search?pretty   查询这个es存储的所有数据

2：查询文档1中的数据

http://192.168.79.131:9200/shb01/student/1?pretty

http://192.168.79.131:9200/shb01/student/1?_source&pretty
http://192.168.79.131:9200/shb01/student/1?_source=name&pretty

注意：这种写法是错误的  http://123.207.56.239:9200/shb01/student/1/_search?pretty   /_search是多余的

可以通过source指定显示那些字段

3：查询所有索引库信息

浏览器：http://192.168.79.131:9200/_search?pretty

4：根据条件查询

浏览器：http://192.168.79.131:9200/shb01/student/_search?q=name:zs&pretty

查询name为zs的数据

5：查询集群状态

Curl –XGET http://192.168.79.131:9200/_cluster/health?pretty

http://192.168.79.131:9200/_cluster/health?pretty

6：多索引，多类型查询,分页查询,超时

Curl：curl -XGET http://192.168.79.131:9200/shb01,shb02/stu,tea/_search?pretty

curl -XGET http://192.168.79.131:9200/_all/stu,tea/_search?pretty

浏览器去掉curl –XGET即可

分页

curl -XGET http://192.168.79.131:9200/shb01/stu/_search?size=2&from=0

超时

     curl -XPOST http://192.168.79.131:9200/_search?_timeout=100




更新

Es

部分更新

如果文档1的字段很多而我们只需要更新其中的一两个字段则可以通过doc指定需要修改的字段其他字段则不必修改。

crul –XPUT

http:192.168.79.131:9200/shb01/student/1/_update?version=1

 –d ‘{“doc”:{“name”:”updatename”}’

 

全量更新：

    更新文档1中所有字段的内容。

curl -XPUThttp://192.168.79.131:9200/shb01/student/1 -d'{"name":"will","age":100,"info":"newonw"}'

 

更新流程

es会将旧的文档进行标记然后再添加新数据，旧的文档也不能再被访问，在后续添加数据时es会清理已经为删除状态的数据。

删除

删除文档并不会立即生效，只会将其标记为已删除，当后续添加更多索引时才会在后台删除。

curl -XDELETE http://192.168.79.131:9200/shb01/student/AVad05EExskBS1Rg2tdq

根据id删除，删除成功返回found:true，找不到found:false,版本号都会加1。



根据条件删除,删除索引shb01，shb02种类型student，tea中所有name为zs的文档

curl -XDELETEhttp://192.168.79.131:9200/shb01,shb02/student,tea/_query?q=name:zs



删除所有的索引库中名称为tom的文档

curl -XDELETE http://192.168.79.131:9200/_all/_query?q=name:tom

 

批处理

将一批数据加载入内存然后和es交互一次，一次性同时处理多个请求和redis的管道类似。

格式：

Action:index/create/delete/update

Metadata:_index/_type/_id

Create：如果数据存在则报错；index：如果数据存在仍会执行成功。

步骤：

1：在liunx下创建一个文件request1，vi request1

    {"index":{"_index":"shb01","_type":"student","_id":"1"}}

{"name":"st01","age":"10","info":"st01"}

{"create":{"_index":"shb100","_type":"student","_id":"2"}}

{"name":"tea01","age":"10","info":"tea01"}

{"delete":{"_index":"shb01","_type":"student","_id":"AVadzuNgxskBS1Rg2tdp"}

{"update":{"_index":"shb02","_type":"tea","_id":"1"}}

{"doc":{"name":"zszszszs"}}

 

文件中

index表示操作类型

_index指定索引库，_type指定类型，_id指定操作文档

 

 

2：执行批处理命令，关键字_bulk

curl  -XPUT http://192.168.79.131:9200/_bulk --data-binary @/usr/local/request1

注意：--data-binary@之间有空格隔开，我在实验中没有空格一直提示操作参数不对。

 

3：返回值

{

"took":957,"errors":false,"items":[

{"index":{"_index":"shb01","_type":"student","_id":"1","_version":12,"status":200}},

{"create":{"_index":"shb100","_type":"student","_id":"2","_version":1,"status":201}},

{"delete":{"_index":"shb01","_type":"student","_id":"AVadzuNgxskBS1Rg2tdp","_version":2,"status":200,"found":true}},

{"update":{"_index":"shb02","_type":"tea","_id":"1","_version":2,"status":200}}

]

 

返回信息中errors表示批处理有没有错误，注意version和status，其中shb100为新创建的索引库

下面是我第二次执行request1文件的返回信息，errors为true，表示批处理中有操作执行失败，可以看到create因为库中已有id相同的文档所以报错。但是虽然存在错误操作但其他的操作依然成功执行。这点和redis中的事务操作类似。

{

"took":22,"errors":true,"items":[

{"index":{"_index":"shb01","_type":"student","_id":"1","_version":13,"status":200}},

{"create":{"_index":"shb100","_type":"student","_id":"2","status":409,"error":"DocumentAlreadyExistsException[[shb100][3][student][2]: document already exists]"}},

{"delete":{"_index":"shb01","_type":"student","_id":"AVadzuNgxskBS1Rg2tdp","_version":1,"status":404,"found":false}},

{"update":{"_index":"shb02","_type":"tea","_id":"1","_version":3,"status":200}}

]

}

 

4：在命令中指定索引库和类型

创建一个文件，文件中没有配置索引库和类型

{"index":{"_id":"1"}}

{"name":"st1_1","age":"10","info":"st1_1"}

{"create":{"_id":"200"}}

{"name":"st200","age":"10","info":"st200"}

 

执行如下命令，在命令中指定了索引库和类型

curl  -XPUT http://192.168.79.131:9200/shb01/student/_bulk --data-binary@/usr/local/request2

 

返回信息

{

"took":24,"errors":false,"items":[

{"index":{"_index":"shb01","_type":"student","_id":"1","_version":17,"status":200}},

{"create":{"_index":"shb01","_type":"student","_id":"200","_version":1,"status":201}}

]

}

 

5：也可以使用-XPOST替换-XPUT




























