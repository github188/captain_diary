类图是这样的，
ReadWriteLock接口（这个接口跟Lock接口没有半毛钱关系）下面的实现类RenentrantReadWriteLock
张孝祥：读写锁卡农控制粒度比synchronized更加细致，且他只能在代码块上加锁，也就是说她锁的是对象，不能锁类。两个线程要达到互斥的效果，必须用同一个读写锁，那么用ReentrantLock行不行，达不到读写锁这么细颗粒度的控制。

对象下面的读锁和写锁。锁是要上在共享的任务实例的内部方法中的代码块上的，而不是线程代码上。
读锁与读锁不互斥，读锁与写锁互斥，写锁与读锁互斥，写锁与写锁互斥。前提是都是同一个读写锁啊。面试题用读写锁写一个缓存类。
我在总结一下：一个线程读的时候，另一个线程不能写但可以读（正是因为这个特性使得写多读少的场景下提升了性能，因为面试经常问到），
一个线程写的时候，另一个线程也不能读，夜不能写。欧拉。
我的一个疑问是，既然读锁与读锁不互斥，那么所线程都是读的情况下，还有加读锁的必要吗，那确实没必要，但是如果读的时候不希望有写锁包围的代码被执行，
那就必须要
加读锁，另外一块代码要加写锁。另外，我觉得不要被这个读写的名字局限了，凡是需要用到这个互斥特性的地方都可以使用读写锁。

``` java 
import java.util.HashMap;
import java.util.concurrent.locks.ReentrantReadWriteLock;
public class ReentrantLockDemo {
	public static void main(String[] args) {
		Task task = new Task();
		for (int i = 0; i < 10; i++) {
			new Thread(task).start();
		}
	}
}
class Task implements Runnable{
	ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();
	HashMap map = new HashMap();
	@Override
	public void run() {
//		reentrantReadWriteLock.readLock().lock();
//		System.out.println(Thread.currentThread().getName()+"------------into readLock-----------");
		reentrantReadWriteLock.writeLock().lock();
		System.out.println(Thread.currentThread().getName()+"------------into writeLock-----------");
		System.out.println(Thread.currentThread().getName()+"   sleeping........");
		map.put(Thread.currentThread().getName(), Thread.currentThread().getName());
		try {
			Thread.currentThread().sleep(300);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println("------------out writeLock-----------");
//		reentrantReadWriteLock.readLock().unlock();
		reentrantReadWriteLock.writeLock().unlock();
}
}

------------
Thread-0------------into writeLock-----------
Thread-0   sleeping........
------------out writeLock-----------
Thread-1------------into writeLock-----------
Thread-1   sleeping........
------------out writeLock-----------
Thread-2------------into writeLock-----------
Thread-2   sleeping........
------------out writeLock-----------
Thread-3------------into writeLock-----------
Thread-3   sleeping........
------------out writeLock-----------
Thread-4------------into writeLock-----------
Thread-4   sleeping........
------------out writeLock-----------
Thread-5------------into writeLock-----------
Thread-5   sleeping........
------------out writeLock-----------
Thread-6------------into writeLock-----------
Thread-6   sleeping........
------------out writeLock-----------
Thread-7------------into writeLock-----------
Thread-7   sleeping........
------------out writeLock-----------
Thread-8------------into writeLock-----------
Thread-8   sleeping........
------------out writeLock-----------
Thread-9------------into writeLock-----------
Thread-9   sleeping........
------------out writeLock-----------
------------

把上面的//去掉，为什么结果是
Thread-0------------into readLock-----------
Thread-4------------into readLock-----------
Thread-3------------into readLock-----------
Thread-2------------into readLock-----------
Thread-1------------into readLock-----------
而不是所有线程都能进入读锁，我感觉这事没法解释
```
另外就是用读写锁写一个缓存的读写



