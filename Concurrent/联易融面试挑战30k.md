下面的每一个问题，讲不出什么深度出来，就会失败了，人家要求是很高的，成功把握目前只有1成，或许还不到。
下面的每一题的答案都要写一张A4纸出来，如果写不出来，就要看视频，张孝祥的深度还可以。

综合1： 画架构图

1.java集合
集合的好处：1是可变容量  2.是可以存放不同类型的元素  3.增删改查算法优化  4.部分支持线程安全
Collections - List接口 -Map接口  -Queue接口 
List接口 ： 有序可重复  Arraylist 查快 增删改慢（用挪动其他元素）  LinkedList 查比较慢 增删改快（不用挪动其他元素） Vector 3个
可以用List的特性做队列和栈容器  用addLast/First pollFirst/Last  removeFirst/Last（）在在集合为空的时候会报空指针异常。
List接口里面有contains()方法，不要傻逼比再去用for循环了。
set接口  : 无序不可重复  HashSet treeSet   2个

Map 接口 ：  treeMap  HashMap    HashTable 3个

也很重要，能装逼的类：ArrayQueue， Stack（Verctor子类） WeakHashMap()  SortedMap() SortedSet()
EnumHashMap EnumHashSet  LinkedHashMap LinkedHashSet NavigableMap NavigableSet RegularEnumSet
还有并发包下面的集合   
BlockingQueue BlockingDequeue   ArrayBlockingQueue  还有SynchronousQueue （用在缓冲线程池里面）
ConcurrentHashMap 
ConcurrentLinkedDequeue
ConcurrentLinkedQueue
ConcurrentSkipListMap
ConcurrentSkipListSet
CopyOnWriteArrayList
CopyOnWriteArraySet
DelayQueue

这下真有三十个集合了。


ForkJoinPool FokJoinTask 干嘛用的 当然这根集合框架无关  CompletableFuture
我曹  读源码包真的好有意思

2.多线程 
传统方法，jdk1.5以前，只有两种方法创建多线程，一个是继承Thread类，另一个是实现Runnable接口。
此外，就是用线程池来实现了，话题转到了4.

3.线程安全CAS 
原子类嘛，张孝祥讲的，compareAndSet方法来保证的。这是一个直接操作硬件的方法。


4.线程池  
首先那个Executor继承实现关系图，面试要画出来。这一点对理解线程池执行者的理解非常有好处。
[image](https://github.com/huangleisir/common-pics/blob/master/executor.jpg)
I 用Executors帮助类来创建线程，一共可以创建4种类型的线程，分别说一下：
newFixedThreadPool(),固定线程数的线程池，
newSingleThreadPool(),返回单个线程的线程池，
newCacheableThreadPool(),返回缓冲线程池（corePoolSize指定线程数的最小值，maximumPoolSize指定线程数的最大值）
newScheduledThreadPool()
II concurrent集合类 HashMap HashSet LinkedList
III 锁 sychronized  Lock  RenentranLock ReadLock WriteLock  读写锁巧妙解决缓存读写的问题
刚才灵光一现，突然理解了读锁和写锁的妙处，感觉之前的理解是有错误的。
private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();这是一个读写锁对象，它里面有一对锁，一个读锁，一个写锁。
当一块代码添加了读锁，多个线程是可以并发近来读的，但是在读锁释放前，写锁是锁不上的，线程会等待知道读锁释放。这就是所谓的读锁和写锁互斥。同样道理，
写锁未释放前，这个写锁的兄弟读锁包裹的代码块也不能被执行。
·
读写锁：分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由jvm自己控制的，你只要上好相应的锁即可。如果你的代码只读数据，可以很多人同时读，但不能同时写（这里的同时，也包括读锁未释放前），那就上读锁；如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！·
http://blog.csdn.net/com360/article/details/6797576
https://www.cnblogs.com/zzlp/p/5174745.html  这两个博客读写锁释放的时序不一样，应该只有一个是正确的。
5.spring ，IOC/AOP

5.1动态代理，反射
动态代理有两种方式：
1.直接用jdk实现动态代理；
 UserService userServiceProxy = (UserService)Proxy.newProxyInstance(userService.getClass().getClassLoader(),  
                userService.getClass().getInterfaces(), invocationHandler); 
2.cglib动态代理；
Cglib是一个优秀的动态代理框架，它的底层使用ASM在内存中动态的生成被代理类的子类，使用CGLIB即使代理类没有实现任何接口也可以实现动态代理功能。
CGLIB具有简单易用，它的运行速度要远远快于JDK的Proxy动态代理：
>import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;
import java.lang.reflect.Method;
public class CglibProxy implements MethodInterceptor {
    @Override
    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        System.out.println("++++++before " + methodProxy.getSuperName() + "++++++");
        System.out.println(method.getName());
        Object o1 = methodProxy.invokeSuper(o, args);
        System.out.println("++++++before " + methodProxy.getSuperName() + "++++++");
        return o1;
    }
}

>package com.meituan.hyt.test3.cglib;
import com.meituan.hyt.test3.service.UserService;
import com.meituan.hyt.test3.service.impl.UserServiceImpl;
import net.sf.cglib.proxy.Enhancer;
public class Main2 {
    public static void main(String[] args) {
        CglibProxy cglibProxy = new CglibProxy();
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(UserServiceImpl.class);
        enhancer.setCallback(cglibProxy);
        UserService o = (UserService)enhancer.create();
        o.getName(1);
        o.getAge(1);
    }
}
实现代码很简单   http://blog.csdn.net/heyutao007/article/details/49738887

6.数据库优化      https://ke.qq.com/course/255238  这个里面很简洁的讲了主从配置读写分离
分库分表，读写分离 ，主从复制怎么做

7.数据库索引，sql优化   布尔学院那里的总结比较好


8.分布式：dubbo架构和zk原理 


9.jvm运行时数据图  GC 内存溢出 CPU高等解决办法 


10分布式事务

10.1 分布式锁 

11.高并发怎么处理


12.缓存，缓存穿透，缓存并发（key不存在时加分布式锁，查db入缓存，再解锁，缓存雪崩（设置过期时间为随机值，避免同一时间大并发请求DB））
另外，用ConcurrentHashMap也可以自己做一个简单的缓存。
缓存穿透：大量的不存在的key进来查询，这样肯定穿透到db上面来了，怎么办，特别是有人恶意攻击，可以先用key查一下db，不存在，则在缓存中也缓存一下这个key
，value给一个比较特殊的值，比如“N”.下次再来查的时候，直接返回N，前端约定好就知道啥意思了。后面这个key有数据了，直接update就行了。

 
