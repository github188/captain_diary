下面的每一个问题，讲不出什么深度出来，就会失败了，人家要求是很高的，成功把握目前只有1成，或许还不到。
下面的每一题的答案都要写一张A4纸出来，如果写不出来，就要看视频，张孝祥的深度还可以。

综合1： 画架构图

1.java集合
集合的好处：1是可变容量  2.是可以存放不同类型的元素  3.增删改查算法优化  4.部分支持线程安全
Collections - List接口 -Map接口  -Queue接口 
List接口 ： 有序可重复  Arraylist 查快 增删改慢（用挪动其他元素）  LinkedList 查比较慢 增删改快（不用挪动其他元素） Vector 3个
可以用List的特性做队列和栈容器  用addLast/First pollFirst/Last  removeFirst/Last（）在在集合为空的时候会报空指针异常。
List接口里面有contains()方法，不要傻逼比再去用for循环了。
set接口  : 无序不可重复  HashSet treeSet   2个

Map 接口 ：  treeMap  HashMap    HashTable 3个

也很重要，能装逼的类：ArrayQueue， Stack（Verctor子类） WeakHashMap()  SortedMap() SortedSet()
EnumHashMap EnumHashSet  LinkedHashMap LinkedHashSet NavigableMap NavigableSet RegularEnumSet
还有并发包下面的集合   
BlockingQueue BlockingDequeue   ArrayBlockingQueue  还有SynchronousQueue （用在缓冲线程池里面）
ConcurrentHashMap 
ConcurrentLinkedDequeue
ConcurrentLinkedQueue
ConcurrentSkipListMap
ConcurrentSkipListSet
CopyOnWriteArrayList
CopyOnWriteArraySet
DelayQueue

这下真有三十个集合了。


ForkJoinPool FokJoinTask 干嘛用的 当然这根集合框架无关  CompletableFuture
我曹  读源码包真的好有意思

2.多线程 


3.线程安全CAS 
原子类嘛，张孝祥讲的，compareAndSet方法来保证的。这是一个直接操作硬件的方法。


4.线程池  

5.spring ，IOC/AOP

5.1动态代理，反射
动态代理有两种方式：
1.直接用jdk实现动态代理；
 UserService userServiceProxy = (UserService)Proxy.newProxyInstance(userService.getClass().getClassLoader(),  
                userService.getClass().getInterfaces(), invocationHandler); 
2.cglib动态代理；
Cglib是一个优秀的动态代理框架，它的底层使用ASM在内存中动态的生成被代理类的子类，使用CGLIB即使代理类没有实现任何接口也可以实现动态代理功能。
CGLIB具有简单易用，它的运行速度要远远快于JDK的Proxy动态代理：
>import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;
import java.lang.reflect.Method;
public class CglibProxy implements MethodInterceptor {
    @Override
    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        System.out.println("++++++before " + methodProxy.getSuperName() + "++++++");
        System.out.println(method.getName());
        Object o1 = methodProxy.invokeSuper(o, args);
        System.out.println("++++++before " + methodProxy.getSuperName() + "++++++");
        return o1;
    }
}

>package com.meituan.hyt.test3.cglib;
import com.meituan.hyt.test3.service.UserService;
import com.meituan.hyt.test3.service.impl.UserServiceImpl;
import net.sf.cglib.proxy.Enhancer;
public class Main2 {
    public static void main(String[] args) {
        CglibProxy cglibProxy = new CglibProxy();
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(UserServiceImpl.class);
        enhancer.setCallback(cglibProxy);
        UserService o = (UserService)enhancer.create();
        o.getName(1);
        o.getAge(1);
    }
}
实现代码很简单   http://blog.csdn.net/heyutao007/article/details/49738887

6.数据库优化      https://ke.qq.com/course/255238  这个里面很简洁的讲了主从配置读写分离
分库分表，读写分离 ，主从复制怎么做

7.数据库索引，sql优化   布尔学院那里的总结比较好


8.分布式：dubbo架构和zk原理 


9.jvm运行时数据图  GC 内存溢出 CPU高等解决办法 


10分布式事务

11.高并发怎么处理

